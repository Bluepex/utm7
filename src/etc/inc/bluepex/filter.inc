<?php
/* ====================================================================
* Copyright (C) BluePex Security Solutions - All rights reserved
* Unauthorized copying of this file, via any medium is strictly prohibited
* Proprietary and confidential
* Written by Guilherme R. Brechot <guilherme.brechot@bluepex.com>, 2023
* ====================================================================
*
* Filter by BluePex
*/

function getInterfacesInGatewaysWithNoExceptions_redeclare_in_page() {

	init_config_arr(array('installedpackages', 'suricata', 'rule'));
	init_config_arr(array('gateways', 'gateway_item'));
	$a_gtw = &$config['gateways']['gateway_item'];
	$a_gateways = return_gateways_array(true, false, true, true);
	$gtw_exceptions = [];
	if (file_exists('/etc/if_ex_wan.conf')) {
		$gtw_exceptions = array_unique(array_filter(explode(",",file_get_contents("/etc/if_ex_wan.conf"))));
	}

	$all_gtw = [];

	foreach($a_gateways as $gtw_rules) {
		$gtw_interface = get_real_interface($gtw_rules['interface']);
		if (!in_array($gtw_interface, $gtw_exceptions)) {
			$all_gtw[] = $gtw_interface;
		}
	}

	if (file_exists("/etc/if_ex_lan.conf")) {
		$if_ex_lan = explode(",",file_get_contents("/etc/if_ex_lan.conf"));
		foreach($if_ex_lan as $if_ex_lan_now) {
			$all_gtw[] = $if_ex_lan_now;
		}
	}
	
	return array_unique(array_filter($all_gtw));

}

function get_heuristc_interfaces_redeclare_in_page() {

	global $config;

	$heuristic_interfaces = [];
	if (isset($config['installedpackages']['suricata']['rule'])) {
		foreach($config['installedpackages']['suricata']['rule'] as $suricatacfg) {
			if ($suricatacfg['ips_mode'] == "ips_mode_inline") {
				$heuristic_interfaces[] = get_real_interface($suricatacfg['interface']);
			}
		}
	}

	return array_unique(array_filter($heuristic_interfaces));
}

function enable_performance_extends() {
	$return_value = false;
	if (file_exists("/etc/performance_extends")) {
		if (trim(file_get_contents("/etc/performance_extends")) == "true") {
			$return_value = true;
		}
	}
	return $return_value;
}

function bp_oneclick_get_rules_config($option) {
	global $g, $config;

	if (empty($option) || !isset($config[$option]['enable']) || ($config[$option]['enable'] != "on") ||
	    !isset($config[$option]['services']['item']) || empty($config[$option]['services']['item'])) {
		return;
	}

	$list_real_interfaces = get_configured_interface_list_by_realif();
	$pf_rules1 = $pf_rules2 = array();
	$pf_tables = array();

	foreach ($config[$option]['services']['item'] as $ocs) {
		$log = ($ocs['log'] == "true") ? "log" : "";
		$ocs_interfaces = !empty($ocs['ifaces']) ? explode(", ", $ocs['ifaces']) : array();

		// Get Real Interfaces of rule
		$real_interfaces = array();
		foreach ($list_real_interfaces as $real_iface => $iface) {
			if (!empty($ocs_interfaces) && !in_array($iface, $ocs_interfaces)) {
				continue;
			}
			$real_interfaces[] = $real_iface;
		}

		// Get Exception Aliases of rule
		$exceptions = array();
		if (!empty($ocs['exceptions']) && isset($config['aliases']['alias'])) {
			$rule_exceptions = explode(", ", $ocs['exceptions']);
			foreach ($config['aliases']['alias'] as $alias) {
				if (in_array($alias['name'], $rule_exceptions)) {
					$exceptions[] = "!<{$alias['name']}>";
				}
			}
		}

		$from = empty($exceptions) ? "any" : "{ " . implode(", ", $exceptions) . " }";
		$ifaces = "{ " . implode(", ", $real_interfaces) . " }";

		if ($ocs['type'] == "common_service") {
			foreach ($ocs['rules']['config'] as $rule) {
				$port = "";
				if (isset($rule['port']) && !empty($rule['port'])) {
					list($src_port, $dst_port) = explode("-", $rule['port']);
					if (!empty($dst_port)) {
						$src_port--;
						$dst_port++;
						$port = "port {$src_port} >< {$dst_port}";
					} else {
						$port = "port {$src_port}";
					}
				}
				$proto = $state = $flags = "";
				if (isset($rule['protocol'])) {
					$proto = "proto { {$rule['protocol']} }";
					if ($ocs['action'] == "pass" && in_array($rule['protocol'], array("tcp", "udp", "icmp"))) {
						$state = "keep state";
					}
					if ($rule['protocol'] == "tcp") {
						$flags = "flags S/SA";
					}
				}
				$pf_rules2[] = "{$ocs['action']} in {$log} quick on {$ifaces} inet {$proto} from {$from} to any {$port} {$flags} {$state} label \"generated by OneClick {$ocs['name']}\"";
			}
		} elseif ($ocs['type'] == "category_service") {
			$filename = $g['www_path'] . "/one_click/lists/{$ocs['name']}.ips";
			if (!file_exists($filename) || !filesize($filename) > 0) {
				continue;
			}
			$pf_tables[] = "table <{$ocs['name']}> persist file \"{$filename}\"";

			if ($option == "one_click") {
				$label = "generated by OneClick, rule {$ocs['name']}";
			} else {
				$label = "generated by Active Protection, rule {$ocs['name']}";
			}
			if ($ocs['action'] == "pass") {
				$pf_rules1[] = "pass in {$log} quick on {$ifaces} inet from {$from} to <{$ocs['name']}> label \"{$label}\"";
			} else {
				// If block action, redirect to OneClick/Active Protection page
				foreach($real_interfaces as $real_iface) {
					$pf_nat_rules[] = "rdr on {$real_iface} proto tcp from {$from} to <{$ocs['name']}> port 80 -> 127.0.0.1 port 48080";
					$pf_nat_rules[] = "rdr on {$real_iface} proto tcp from {$from} to <{$ocs['name']}> port 443 -> 127.0.0.1 port 48083";
					$pf_rules1[] = "pass in quick on {$real_iface} inet proto tcp from {$from} to 127.0.0.1 port 48080 flags S/SA keep state label \"{$label}\"";
					$pf_rules1[] = "pass in quick on {$real_iface} inet proto tcp from {$from} to 127.0.0.1 port 48083 flags S/SA keep state label \"{$label}\"";
				}
			}
		}
	}
	$pf_rules = array_merge($pf_rules1, $pf_rules2);
	$pf_config = array(
		"rules" => !empty($pf_rules) ? implode("\n", $pf_rules) . "\n" : "",
		"tables" => !empty($pf_tables) ? implode("\n", $pf_tables) . "\n" : "",
		"nat" => !empty($pf_nat_rules) ? implode("\n", $pf_nat_rules) . "\n" : ""
	);
	return $pf_config;
}

function get_if_fapp_legacy() {

	global $config, $g, $FilterIflist, $tracker;

	$all_gtw = getInterfacesInGatewaysWithNoExceptions_redeclare_in_page();
	$all_heuristic = get_heuristc_interfaces_redeclare_in_page();
	$return_gtw = [];
	
	foreach($config['interfaces'] as $key_interface => $value_interface) {
		$interface_now = get_real_interface($key_interface);
		if (!in_array($interface_now, $all_gtw)) {
			if (!in_array($interface_now, $all_heuristic)) {
				$return_gtw[] = $interface_now;
			}
		}
	}

	return array_filter(array_unique($return_gtw));

}

function get_if_acp_legacy() {

	global $config, $g, $FilterIflist, $tracker;

	$all_gtw = getInterfacesInGatewaysWithNoExceptions_redeclare_in_page();
	$all_heuristic = get_heuristc_interfaces_redeclare_in_page();
	$return_gtw = [];
	foreach($all_gtw as $interface_now) {
		if (!in_array($interface_now, $all_heuristic)) {
			$return_gtw[] = $interface_now;
		}
	}

	return array_filter(array_unique($return_gtw));
}

function bp_fapp2c_get_rules_config($real_interface="fapp2c", $ifs_interface="") {
	global $g, $config;

	$pf_rules1 = $pf_rules2 = array();
	$pf_tables = array();

	$increment_tracker = 'filter_rule_tracker';

	$ifs = "{ " . implode(",",get_if_fapp_legacy()) . " }";

	$label = "rule block firewallapp";

	$log['block'] = "log";

	if (!empty(get_if_fapp_legacy()) && !enable_performance_extends()) {

		if (!empty($ifs_interface)) {
			$pf_rules1[] = "block in quick on { {$ifs_interface} } inet from <{$real_interface}> to any ridentifier {$increment_tracker()} label \"{$label}\"";
			$pf_rules1[] = "block in quick on { {$ifs_interface} } inet from any to <{$real_interface}> ridentifier {$increment_tracker()} label \"{$label}\"";
		} else {
			$pf_rules1[] = "block in quick on {$ifs} inet from <{$real_interface}> to any ridentifier {$increment_tracker()} label \"{$label}\"";
			$pf_rules1[] = "block in quick on {$ifs} inet from any to <{$real_interface}> ridentifier {$increment_tracker()} label \"{$label}\"";
		}

		$pf_rules = array_merge($pf_rules1, $pf_rules2);
		$pf_config = array(
			"rules" => !empty($pf_rules) ? implode("\n", $pf_rules) . "\n" : "",
			"tables" => !empty($pf_tables) ? implode("\n", $pf_tables) . "\n" : "",
			"nat" => !empty($pf_nat_rules) ? implode("\n", $pf_nat_rules) . "\n" : ""
		);

	}

	return $pf_config;
}

function bp_fapp2c_get_rules_config_exceptions($real_interface="fapp2c", $ifs_interface="" , $ips_target="", $typepass="") {
	global $g, $config;

	$pf_rules1 = $pf_rules2 = array();
	$pf_tables = array();

	$increment_tracker = 'filter_rule_tracker';

	$label = "rule block firewallapp _p_ and _b_ {$real_interface}";

	if (!empty(get_if_fapp_legacy()) && enable_performance_extends()) {

		$passTable = "fapp2c_p_{$real_interface}";
		$blockTable = "fapp2c_b_{$real_interface}";
		$ipsTable = "fapp2c_ips_{$real_interface}";

		if ($typepass == "pass") {
			$pf_rules1[] = "pass in log quick on { {$ifs_interface} } inet from <{$passTable}> to <{$ipsTable}> ridentifier {$increment_tracker()} label \"{$label}\"";
			$pf_rules1[] = "pass in log quick on { {$ifs_interface} } inet from <{$ipsTable}> to <{$passTable}> ridentifier {$increment_tracker()} label \"{$label}\"";
		}

		if ($typepass == "block") {
			$pf_rules1[] = "block in log quick on { {$ifs_interface} } inet from <{$blockTable}> to <{$ipsTable}> ridentifier {$increment_tracker()} label \"{$label}\"";
			$pf_rules1[] = "block in log quick on { {$ifs_interface} } inet from <{$ipsTable}> to <{$blockTable}> ridentifier {$increment_tracker()} label \"{$label}\"";
		}

		$pf_rules = array_merge($pf_rules1, $pf_rules2);
		$pf_config = array(
			"rules" => !empty($pf_rules) ? implode("\n", $pf_rules) . "\n" : "",
			"tables" => !empty($pf_tables) ? implode("\n", $pf_tables) . "\n" : "",
			"nat" => !empty($pf_nat_rules) ? implode("\n", $pf_nat_rules) . "\n" : ""
		);

	}

	return $pf_config;
}

function bp_acp2c_get_rules_config($real_interface="acp2c", $ifs_interface="") {
	global $g, $config;

	$pf_rules1 = $pf_rules2 = array();
	$pf_tables = array();

	$increment_tracker = 'filter_rule_tracker';

	$ifs = "{ " . implode(",",get_if_acp_legacy()) . " }";

	$label = "rule block activeprotection";

	$log['block'] = "log";

	if (!empty(get_if_acp_legacy())) {
		
		if (!empty($ifs_interface)) {
			$pf_rules1[] = "block in quick on { {$ifs_interface} } inet from <{$real_interface}> to any ridentifier {$increment_tracker()} label \"{$label}\"";
			$pf_rules1[] = "block in quick on { {$ifs_interface} } inet from any to <{$real_interface}> ridentifier {$increment_tracker()} label \"{$label}\"";
			$pf_rules1[] = "block out quick on { {$ifs_interface} } inet from <{$real_interface}> to any ridentifier {$increment_tracker()} label \"{$label}\"";
			$pf_rules1[] = "block out quick on { {$ifs_interface} } inet from any to <{$real_interface}> ridentifier {$increment_tracker()} label \"{$label}\"";
		} else {
			$pf_rules1[] = "block in quick on {$ifs} inet from <{$real_interface}> to any ridentifier {$increment_tracker()} label \"{$label}\"";
			$pf_rules1[] = "block in quick on {$ifs} inet from any to <{$real_interface}> ridentifier {$increment_tracker()} label \"{$label}\"";
			$pf_rules1[] = "block out quick on {$ifs} inet from <{$real_interface}> to any ridentifier {$increment_tracker()} label \"{$label}\"";
			$pf_rules1[] = "block out quick on {$ifs} inet from any to <{$real_interface}> ridentifier {$increment_tracker()} label \"{$label}\"";
		}

		$pf_rules = array_merge($pf_rules1, $pf_rules2);
		$pf_config = array(
			"rules" => !empty($pf_rules) ? implode("\n", $pf_rules) . "\n" : "",
			"tables" => !empty($pf_tables) ? implode("\n", $pf_tables) . "\n" : "",
			"nat" => !empty($pf_nat_rules) ? implode("\n", $pf_nat_rules) . "\n" : ""
		);
		
	}

	return $pf_config;
}



?>
